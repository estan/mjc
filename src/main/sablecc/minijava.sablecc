/*
 * Grammar for the MiniJava language.
 *
 * This is a grammar for a slightly modified version of the MiniJava language [1].
 */

Package mjc;

Helpers

    unicode = [0..0xffff];
    letter = ['a' .. 'z'] | ['A' .. 'Z'];
    digit = ['0' .. '9'];

    lf = 0x000a;
    cr = 0x000d;
    ht = 0x0009;
    ff = 0x000c;
    eol = lf | cr | cr lf;

    not_star = [unicode - '*'];
    not_star_not_slash = [unicode - ['*' + '/']];

    block_comment = '/*' not_star* ('*' (not_star_not_slash not_star*)?)* '*/';
    line_comment = '//' [unicode - [cr + lf]]* eol?;

Tokens

    // Keywords
    class_keyword = 'class';
    public_keyword = 'public';
    static_keyword = 'static';
    void_keyword = 'void';
    string_keyword = 'String';
    return_keyword = 'return';
    int_keyword = 'int';
    boolean_keyword = 'boolean';
    if_keyword = 'if';
    else_keyword = 'else';
    while_keyword = 'while';
    println_keyword = 'System.out.println';
    length_keyword = 'length';
    true_keyword = 'true';
    false_keyword = 'false';
    this_keyword = 'this';
    new_keyword = 'new';

    // FIXME: Should "main" be handled as an identifier instead?
    main_literal = 'main';

    // Operators
    plus = '+';
    minus = '-';
    star = '*';
    less_than = '<';
    assign = '=';
    and = '&&';
    not = '!';

    // Punctuation
    comma = ',';
    period = '.';
    semicolon = ';';

    // Bracketing
    lparen = '(';
    rparen = ')';
    lbrack = '[';
    rbrack = ']';
    lbrace = '{';
    rbrace = '}';

    // Miscellaneous
    comment = block_comment | line_comment;
    whitespace = (' ' | ht | ff | eol)+;
    identifier = letter (letter | digit | '_')*;
    integer = digit+;

Ignored Tokens

    whitespace, comment;

Productions

    program = main_class_declaration class_declaration*;

    /*
     * Main class declaration
     *
     * Example(s):
     *     class Foo { public static void main() { int i; i = 42; } }
     */
    main_class_declaration =
        class_keyword [name]:identifier
            [class_begin]:lbrace
                main_prolog lparen string_keyword lbrack rbrack [arg]:identifier rparen
                [method_begin]:lbrace
                    variable_declaration*
                    statement*
                [method_end]:rbrace
            [class_end]:rbrace;

    main_prolog =
        public_keyword static_keyword void_keyword main_literal;

    /*
     * Class declaration
     *
     * Example(s):
     *     class Bar { int foo() { return 42; } }
     */
    class_declaration =
        class_keyword identifier
        lbrace
            variable_declaration*
            method_declaration*
        rbrace;

    /*
     * Method declaration
     *
     * Example(s):
     *     int foo() { return 42; }
     */
    method_declaration =
        public_keyword type identifier lparen formal_parameter_list? rparen
        lbrace
            variable_declaration*
            statement*
            return_keyword expression semicolon
        rbrace;

    /*
     * Variable declaration
     *
     * Example(s):
     *     int x;
     */
    variable_declaration =
        type identifier semicolon;

    /*
     * Formal parameter
     *
     * Example(s):
     *     bool x
     */
    formal_parameter =
        type identifier;

    /*
     * Formal parameter list
     *
     * Example(s):
     *     bool x
     *     bool x, int y, int z
     */
    formal_parameter_list =
        {formal_parameter} formal_parameter |
        {formal_parameters} formal_parameter_list comma formal_parameter;

    /*
     * Type
     *
     * Example(s):
     *     int
     *     int[]
     *     MyClass
     */
    type =
        {int} int_keyword |
        {array} int_keyword lbrack rbrack |
        {boolean} boolean_keyword |
        {object} identifier;

    /*
     * Statement
     *
     * Example(s):
     *     y = x;
     *     if (y < x) System.out.println(x); else System.out.println(y);
     *     { int x; }
     */
    statement =
        {block} lbrace statement* rbrace |
        {if_else} if_keyword lparen expression rparen [true]:statement else_keyword [false]:statement |
        {while} while_keyword lparen expression rparen statement |
        {println} println_keyword lparen expression rparen semicolon |
        {assign} identifier assign expression semicolon |
        {array_assign} identifier lbrack [index]:expression rbrack assign expression semicolon;


    /*
     * Expression productions below.
     *
     * The productions are in decreasing order of precedence.
     */


    /*
     * Literal expression
     *
     * Example(s):
     *     false
     *     345
     */
    literal_expression =
        {integer} integer |
        {true} true_keyword |
        {false} false_keyword;

    /*
     * Primary expression
     *
     * Example(s):
     *    666
     *    false
     *    this
     *    myObj
     *    myArray.length
     *    table[i]
     *    (i + 1)
     */
    primary_expression =
        {literal} literal_expression |
        {identifier} identifier |
        {this} this_keyword |
        {array} array_creation_expression |
        {instance} class_instance_creation_expression |
        {field} field_access |
        {array_access} array_access |
        {method} method_invocation |
        {expression} lparen expression rparen;

    /*
     * Array creation expression
     *
     * Example(s)
     *     new int[myObj.length]
     */
    array_creation_expression =
        new_keyword int_keyword lbrack expression rbrack;

    /*
     * Class instance creation expression
     *
     * Example(s):
     *     new MyClass()
     */
    class_instance_creation_expression =
        new_keyword identifier lparen expression_list* rparen;

    /*
     * Field access
     *
     * Example(s):
     *     myObj.length
     */
    field_access =
        primary_expression period length_keyword;

    /*
     * Field access
     *
     * Example(s):
     *     foo[bar + 1]
     */
    array_access =
        primary_expression lbrack expression rbrack;

    /*
     * Method invocation
     *
     * Example(s):
     *     myObj.add(1, foo)
     */
    method_invocation =
        primary_expression period identifier lparen expression_list* rparen;

    /*
     * Unary expression
     *
     * Example(s):
     *     !myObj.isEmpty()
     *     new int[5]
     */
    unary_expression =
        {primary} primary_expression |
        {negation} not primary_expression;

    /*
     * Multiplicative expression
     *
     * Example(s)
     *     (3 + bar) * (foo - 3 * 2)
     *     !x
     */
    multiplicative_expression =
        {unary} unary_expression |
        {star} multiplicative_expression star unary_expression;

    /*
     * Additive expression
     *
     * Example(s)
     *     1 - (3 + bar)
     *     i + foo
     *     foo * bar
     */
    additive_expression =
        {multiplicative} multiplicative_expression |
        {plus} additive_expression plus multiplicative_expression |
        {minus} additive_expression minus multiplicative_expression;

    /*
     * Relational expression
     *
     * Example(s):
     *     1 + 4
     *     i < foo
     */
    relational_expression =
        {additive} additive_expression |
        {less_than} relational_expression less_than additive_expression;

    /*
     * Conditional AND expression
     *
     * Example(s):
     *     i < foo
     *     i < foo && bar < i
     */
    conditional_and_expression =
        {relational} relational_expression |
        {and} conditional_and_expression and relational_expression;

    /*
     * Conditional expression
     *
     * Example(s):
     *     123634
     *     b < 100
     *     a && b
     */
    conditional_expression =
        conditional_and_expression;

    /*
     * Expression
     *
     * Example(s):
     *     (i < 3 && b < foo && !z)
     *     (i < 3 && b < foo && !z) * 42
     */
    expression =
        conditional_expression;

    /*
     * Expression list
     *
     * Example(s):
     *     123, foo < bar, !x
     *     y
     */
    expression_list =
        {expression} expression |
        {expressions} expression_list comma expression;

/*
 * TODO: Write "Abstract Syntax Tree" section and transformation rules.
 */


