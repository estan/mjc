/*
 * Grammar for the MiniJava language.
 *
 * This is a grammar for a slightly modified version of the MiniJava language [1].
 * 
 * [1] http://www.csc.kth.se/utbildning/kth/kurser/DD2488/komp14/project/grammar14v1.pdf
 */

Package mjc;

Helpers

    unicode = [0..0xffff];
    letter = ['a' .. 'z'] | ['A' .. 'Z'];
    digit = ['0' .. '9'];

    lf = 0x000a;
    cr = 0x000d;
    ht = 0x0009;
    ff = 0x000c;
    eol = lf | cr | cr lf;

    not_star = [unicode - '*'];
    not_star_not_slash = [unicode - ['*' + '/']];

    block_comment = '/*' not_star* ('*' (not_star_not_slash not_star*)?)* '*/';
    line_comment = '//' [unicode - [cr + lf]]* eol?;

Tokens

    // Keywords
    class_keyword = 'class';
    public_keyword = 'public';
    static_keyword = 'static';
    void_keyword = 'void';
    string_keyword = 'String';
    return_keyword = 'return';
    int_keyword = 'int';
    boolean_keyword = 'boolean';
    if_keyword = 'if';
    else_keyword = 'else';
    while_keyword = 'while';
    println_keyword = 'System.out.println';
    length_keyword = 'length';
    true_keyword = 'true';
    false_keyword = 'false';
    this_keyword = 'this';
    new_keyword = 'new';

    // Operators
    plus = '+';
    minus = '-';
    star = '*';
    less_than = '<';
    assign = '=';
    and = '&&';
    not = '!';

    // Punctuation
    comma = ',';
    period = '.';
    semicolon = ';';

    // Bracketing
    lparen = '(';
    rparen = ')';
    lbrack = '[';
    rbrack = ']';
    lbrace = '{';
    rbrace = '}';

    // Miscellaneous
    comment = block_comment | line_comment;
    whitespace = (' ' | ht | ff | eol)+;
    identifier = letter (letter | digit | '_')*;
    integer = digit+;

Ignored Tokens

    whitespace, comment;

Productions

    program = main_class_declaration class_declaration*;

    main_class_declaration =
        class_keyword [name]:identifier
            [class_begin]:lbrace
                public_keyword static_keyword void_keyword identifier lparen string_keyword lbrack rbrack [arg]:identifier rparen
                [method_begin]:lbrace
                    variable_declaration*
                    statement*
                [method_end]:rbrace
            [class_end]:rbrace;

    class_declaration =
        class_keyword identifier
        lbrace
            variable_declaration*
            method_declaration*
        rbrace;

    method_declaration =
        public_keyword type identifier lparen formal_parameter_list? rparen
        lbrace
            variable_declaration*
            statement*
            return_keyword expression semicolon
        rbrace;

    variable_declaration =
        type identifier semicolon;

    formal_parameter =
        type identifier;

    formal_parameter_list =
        {formal_parameter} formal_parameter |
        {formal_parameters} formal_parameter_list comma formal_parameter;

    type =
        {int} int_keyword |
        {array} int_keyword lbrack rbrack |
        {boolean} boolean_keyword |
        {object} identifier;

    statement =
        {block} lbrace statement* rbrace |
        {if_else} if_keyword lparen expression rparen [true]:statement else_keyword [false]:statement |
        {while} while_keyword lparen expression rparen statement |
        {println} println_keyword lparen expression rparen semicolon |
        {assign} identifier assign expression semicolon |
        {array_assign} identifier lbrack [index]:expression rbrack assign expression semicolon;

    expression =
        conditional_expression;

    expression_list =
        {expression} expression |
        {expressions} expression_list comma expression;

    conditional_expression =
        conditional_and_expression;

    conditional_and_expression =
        {relational} relational_expression |
        {and} conditional_and_expression and relational_expression;

    relational_expression =
        {additive} additive_expression |
        {less_than} relational_expression less_than additive_expression;

    additive_expression =
        {multiplicative} multiplicative_expression |
        {plus} additive_expression plus multiplicative_expression |
        {minus} additive_expression minus multiplicative_expression;

    multiplicative_expression =
        {unary} unary_expression |
        {star} multiplicative_expression star unary_expression;

    unary_expression =
        {primary} primary_expression |
        {negation} not primary_expression;

    method_invocation =
        primary_expression period identifier lparen expression_list? rparen;

    array_access =
        primary_expression lbrack expression rbrack;

    field_access =
        primary_expression period length_keyword;

    class_instance_creation_expression =
        new_keyword identifier lparen expression_list* rparen;

    array_creation_expression =
        new_keyword int_keyword lbrack expression rbrack;

    primary_expression =
        {literal} literal_expression |
        {identifier} identifier |
        {this} this_keyword |
        {array} array_creation_expression |
        {instance} class_instance_creation_expression |
        {field} field_access |
        {array_access} array_access |
        {method} method_invocation |
        {expression} lparen expression rparen;

    literal_expression =
        {integer} integer |
        {true} true_keyword |
        {false} false_keyword;

/*
 * TODO: Write "Abstract Syntax Tree" section and transformation rules.
 */


